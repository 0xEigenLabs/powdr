constant %N = 1024;

namespace Main(%N);
    let first = |i| match i { 0 => 1, _ => 0 };
    let Y;
    let Z;
    let bytes = |i| i % 256;
    let wrap_bit;
    wrap_bit * (1 - wrap_bit) = 0;
    let X_b4;
    let X_b3;
    let X_b2;
    let X_b1;
    { X_b4 } in { bytes };
    { X_b3 } in { bytes };
    { X_b2 } in { bytes };
    //{ X_b1 } in { bytes };

    // This should also work at some point:
    // Z * (Z - 1) * (Z - 2) * (Z - 3) = 0;
    // { Z } in { bytes };
    // { Z * 2**6 } in { bytes };
    { Z } in { two_bits };
    let two_bits = |i| i % 4;

    Y = wrap_bit * 2**32 + X_b4 * 0x1000000 + X_b3 * 0x10000 + X_b2 * 0x100 + X_b1 * 4 + Z;
    //{ X_b1 * 4 } in { bytes };
    let six_bits = |i| i % 2**6;
    { X_b1 } in { six_bits };

    Y' = (1 - first') * (Y + 1);
    // {
    //     X_b4 * 0x1000000 + X_b3 * 0x10000 + X_b2 * 0x100 + X_b1 * 4,
    //     STEP,
    //     X
    // } is m_is_read { m_addr, m_step, m_value }
    // // We could even do the lookup with W instead of X and then:
    // // { W, X, Z} in { shr.value, shr.amount, shr.amount}