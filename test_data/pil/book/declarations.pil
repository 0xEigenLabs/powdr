namespace Main(16);
// ANCHOR: declarations
    // This defines a constant
    let rows = 2**16;
    // This defines a fixed column that contains the row number in each row.
    let step = |i| i;
    // This defines a copy of the column, also a fixed column because the type
    // is explicitly specified.
    let also_step: col = step;
    // Here, we have a witness column.
    let x;
    // This functions returns the square of its input (classified as a fixed column).
    let square = |x| x*x;
    // A recursive function, taking a function and an integer as parameter
    let sum = |f, i| match i {
        0 => f(0),
        _ => f(i) + sum(f, i - 1)
    };
    // The same function as "square" above, but if we specify the type
    // and it is not "col" or "int -> fe", it will be stored as a utility
    // function instead of as a column. Utility functions cannot be
    // used in identities without being evaluated.
    let square_non_column: int -> int = |x| x*x;
// ANCHOR_END: declarations
    // We need at least one constraint to create a proof in the test.
    let w;
    w + square = 0;