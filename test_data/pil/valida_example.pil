// This is an example .pil file containing powdr asm
// that could be generated from the following valida program:
//
//   imm32 4(fp), 100
//   jal 0(fp), main, 4
// loop:
//   beq loop, 0(fp), 0(fp) // there is no unconditional jump... We shold probabyl add it to improve prover loop
// main:
//   beqi exit, 0(fp), 0
//   add 4(fp), 0(fp), 0(fp)
//   subi 0(fp), 0(fp), 1
//   beq main, 0(fp), 0(fp)
// exit:
//   jalv 4(fp), 0(fp), 0
//
//
// The purpose is to check if it is easily possible to generate
// a compiler from valida assembly to powdr.

macro is_binary(X) { X * (1 - X) = 0; };
macro mutually_exclusive(X, Y) { X * Y = 0; };

namespace Memory(1024);
  col witness addr;
  col witness step;
  col witness value;
  col witness is_load1;
  col witness is_load2;
  col witness is_write;

  // columns are sorted by addr, then by step and then in the order
  // load1, load2, write.

  col witness address_change;
  col witness step_change;

  col witness op;
  op = is_load1 + is_load2 * 2 + is_write * 3;

  is_binary(is_load1);
  is_binary(is_load2);
  is_binary(is_write);
  mutually_exclusive(is_load1, is_load2);
  mutually_exclusive(is_load1, is_write);
  mutually_exclusive(is_load2, is_write);

  col fixed POSITIVE(i) { i + 1 };
  col fixed FIRST = [1] + [0]*;
  col fixed LAST(i) { FIRST(i + 1) };

  // if address_change is zero, then addr stays the same.
  (1 - address_change) * (addr' - addr) = 0;
  // if address_change is one, then addr increases (except on the last row)
  ((1 - LAST) * address_change) { addr' - addr } in { POSITIVE };

  (1 - step_change) * (step' - step) = 0;
  ((1 - LAST) * step_change) { step' - step } in { POSITIVE };

  // If the step does not change, the operation has to increase.
  (1 - step_change) { op' - op } in { POSITIVE };

  // If the next line is not a write and we stay at the same address, then the
  // value cannot change.
  (1 - is_write') * (1 - address_change) * (value' - value) = 0;

  // If the next line is not a write and we have an address change,
  // then the value is zero.
  (1 - is_write') * address_change * value' = 0;

namespace Main(1024);

macro memory_write(address, value) {
    { address, STEP, value }
    is
    Memory.is_write { Memory.addr, Memory.step, Memory.value };
};

macro memory_load_to_tmp1(address) {
    { address, STEP, tmp1 }
    is
    Memory.is_load1 { Memory.addr, Memory.step, Memory.value };
};

macro memory_load_to_tmp2(address) {
    { address, STEP, tmp2 }
    is
    Memory.is_load2 { Memory.addr, Memory.step, Memory.value };
};

macro branch_if(condition, target) {
    pc' = condition * target + (1 - condition) * (pc + 1);
};

macro is_u32(x) {
    x = b1 + b2 * 0x100 + b3 * 0x10000 + b4 * 0x1000000;
};

col fixed STEP(i) { i };
col fixed FIRST = [1] + [0]*;

col witness tmp1;
col witness tmp2;
col witness tmp3;
col witness tmp3_inv;
col witness tmp3_is_zero;

tmp3_is_zero = 1 - tmp3 * tmp3_inv;
tmp3_is_zero * tmp3 = 0;
tmp3_is_zero * (1 - tmp3_is_zero) = 0;

col witness b1;
col witness b2;
col witness b3;
col witness b4;
col fixed BYTE(i) { i & 0xff };
{ b1 } in { BYTE };
{ b2 } in { BYTE };
{ b3 } in { BYTE };
{ b4 } in { BYTE };
col witness sign_bit;
sign_bit * (1 - sign_bit) = 0;

FIRST * (fp - 0x1000) = 0;

assembly {
    reg pc[@pc];
    reg fp;

    instr imm32 fp_delta: signed, v: unsigned {
        memory_write(fp + fp_delta, v)
    }
    instr jal fp_delta: signed, target: label, shift: signed {
        memory_write(fp + fp_delta, pc + 1),
        pc' = target,
        fp' = fp + shift
    }
    instr jalv fp_delta: signed, target_delta: signed, shift: signed {
        memory_load_to_tmp1(fp + target_delta),
        memory_write(fp + fp_delta, pc + 1),
        pc' = tmp1,
        fp' = fp + shift
    }
    instr beq target: label, a: signed, b: signed {
        memory_load_to_tmp1(fp + a),
        memory_load_to_tmp2(fp + b),
        tmp3 = tmp1 - tmp2,
        branch_if(tmp3_is_zero, target)
    }
    instr beqi target: label, fp_delta: signed, c: unsigned {
        memory_load_to_tmp1(fp + fp_delta),
        tmp3 = tmp1 - c,
        branch_if(tmp3_is_zero, target)
    }
    instr add dest_delta: signed, a_delta: signed, b_delta: signed {
        memory_load_to_tmp1(fp + a_delta),
        memory_load_to_tmp2(fp + b_delta),
        tmp3 = tmp1 + tmp2 - sign_bit * 2**32,
        is_u32(tmp3),
        memory_write(fp + dest_delta, tmp3)
    }
    instr subi dest_delta: signed, b_delta: signed, c: unsigned {
        memory_load_to_tmp1(fp + b_delta),
        tmp3 = tmp1 - c + sign_bit * 2**32,
        is_u32(tmp3),
        memory_write(fp + dest_delta, tmp3)
    }

    // This was "fp + 4", but it's always relative to fp, so we don't need it.
    imm32 4, 100;
    jal 0, main, 4;
  loop::
    beq loop, 0, 0;
main::
    beqi exit, 0, 0;
    add 4, 0, 0;
    subi 0, 0, 1;
    beq main, 0, 0;
  exit::
    jalv 4, 0, 0;
};