constant %N = 65536;

namespace std::convert(%N);
	// Due to its name, the semantics of this function will be overridden.
	// We ensure that this happens by making it diverge in its given semantics.
    let int = [|i| int(i)];
	let fe = [|i| fe(i)];

// ORs two 32-bit numbers, byte-by-byte.
namespace Or(%N);
	let fe = std::convert::fe;
	let to_col: (int -> int) -> col = |f| |i| std::convert::fe(f(i));

	let RESET: col = to_col(|i| if (i % 4) == 3 { 1 } else { 0 } );
	let FACTOR: col = to_col(|i| 1 << (((i + 1) % 4) * 8) );

	col fixed P_A(i) { fe(i % 256) };
	col fixed P_B(i) { fe((i >> 8) % 256) };
	col fixed P_C(i) { fe((std::convert::int(P_A(i)) | std::convert::int(P_B(i))) & 0xff) };

	// ROW RESET  FACTOR
	//   0   0    1 << 8
	//   1   0    1 << 16
	//   2   0    1 << 24
	//   3   1    1 << 0

	col witness A_byte;
	col witness B_byte;
	col witness C_byte;

	col witness A;
	col witness B;
	col witness C;

	A' = A * (1 - RESET) + A_byte * FACTOR;
	B' = B * (1 - RESET) + B_byte * FACTOR;
	C' = C * (1 - RESET) + C_byte * FACTOR;

	{A_byte, B_byte, C_byte} in {P_A, P_B, P_C};

namespace Main(%N);
	let fe = std::convert::fe;
	col fixed a(i) { fe((i + 13) & 0xffffffff) };
	col fixed b(i) { fe(((i + 19) * 17) & 0xffffffff) };
	col witness c;
	col fixed NTH(i) { fe(if i % 32 == 0 { 1 } else { 0 }) };

	NTH {a, b, c} in Or.RESET {Or.A, Or.B, Or.C};

