use std::str::FromStr;
use crate::parser::ast::*;

grammar;

match {
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _,
}

pub PILFile: PILFile = {
    (<Statement> ";")* => PILFile(<>)

};

Statement = {
    Include,
    Namespace,
    PolynomialDefinition,
    PolynomialConstantDeclaration,
    ConstantDefinition,
};

Include: Statement = {
    "include" <file:StringLiteral> => Statement::Include(<>)
};

Namespace: Statement = {
    "namespace" <name:Identifier> "(" <pol_degree:Expression> ")" => Statement::Namespace(<>)
}

PolynomialDefinition: Statement = {
    "pol" <Identifier> "=" <Expression> => Statement::PolynomialDefinition(<>)
}

PolynomialConstantDeclaration: Statement = {
    "pol" "constant" <Identifier> => Statement::PolynomialConstantDeclaration(<>)
}

ConstantDefinition: Statement = {
    "constant" <ConstantIdentifier> "=" <Expression> => Statement::ConstantDefinition(<>)
}

Expression: Expression = {
    SumExpression => *<>,
}

SumExpression: Box<Expression> = {
    SumExpression SumOp Product => Box::new(Expression::BinaryOperation(<>)),
    Product,
}

SumOp: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Sub,
}

Product: Box<Expression> = {
    Product ProductOp Power => Box::new(Expression::BinaryOperation(<>)),
    Power,
}

ProductOp: BinaryOperator = {
    "*" => BinaryOperator::Mul,
    "/" => BinaryOperator::Div,
}

Power: Box<Expression> = {
    <Power> <PowOp> <Term> => Box::new(Expression::BinaryOperation(<>)),
    Term,
}

PowOp: BinaryOperator = {
    "**" => BinaryOperator::Pow,
}

Term: Box<Expression> = {
    ConstantIdentifier => Box::new(Expression::Constant(<>)),
    Number => Box::new(Expression::Number(<>)),
    "(" <SumExpression> ")",
}

StringLiteral: String = {
    r#""[^"]*""# => <>[1..<>.len() - 1].to_string()
}

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z$_0-9]+" => <>.to_string()
}

ConstantIdentifier: String = {
    // TODO it seems the lexer splits the token after %
    "%N" => <>.to_string(),
    r"%[a-zA-Z_][a-zA-Z$_0-9]+" => <>.to_string(),
}

Number: u64 = {
    r"[0-9]+" => u64::from_str(<>).unwrap(),
}